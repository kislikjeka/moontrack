package ledger

import (
	"math/big"
	"time"

	"github.com/google/uuid"
)

// TransactionType represents the type of a ledger transaction
type TransactionType string

const (
	TxTypeManualIncome    TransactionType = "manual_income"
	TxTypeManualOutcome   TransactionType = "manual_outcome"
	TxTypeAssetAdjustment TransactionType = "asset_adjustment"
)

// AllTransactionTypes returns all valid transaction types
func AllTransactionTypes() []TransactionType {
	return []TransactionType{
		TxTypeManualIncome,
		TxTypeManualOutcome,
		TxTypeAssetAdjustment,
	}
}

// IsValid checks if the transaction type is valid
func (t TransactionType) IsValid() bool {
	switch t {
	case TxTypeManualIncome, TxTypeManualOutcome, TxTypeAssetAdjustment:
		return true
	}
	return false
}

// String returns the string representation
func (t TransactionType) String() string {
	return string(t)
}

// Label returns human-readable label for UI
func (t TransactionType) Label() string {
	switch t {
	case TxTypeManualIncome:
		return "Income"
	case TxTypeManualOutcome:
		return "Outcome"
	case TxTypeAssetAdjustment:
		return "Adjustment"
	default:
		return "Unknown"
	}
}

// TransactionStatus represents the status of a transaction
type TransactionStatus string

const (
	TransactionStatusCompleted TransactionStatus = "COMPLETED"
	TransactionStatusFailed    TransactionStatus = "FAILED"
)

// Transaction represents a financial transaction that generates ledger entries
// This is the aggregate root for the double-entry system
type Transaction struct {
	ID           uuid.UUID
	Type         TransactionType           // TxTypeManualIncome, TxTypeManualOutcome, TxTypeAssetAdjustment
	Source       string                    // manual, debank, etherscan, etc.
	ExternalID   *string                   // Blockchain tx hash or external system ID
	Status       TransactionStatus
	Version      int                       // Optimistic locking
	OccurredAt   time.Time                 // When transaction actually happened
	RecordedAt   time.Time                 // When recorded in our system
	RawData      map[string]interface{}    // Original transaction struct for audit (JSONB)
	Metadata     map[string]interface{}    // Additional metadata (JSONB)
	ErrorMessage *string                   // If status = FAILED
	Entries      []*Entry                  // Ledger entries generated by this transaction
}

// Validate validates the transaction
func (t *Transaction) Validate() error {
	if !t.Type.IsValid() {
		return ErrInvalidTransactionType
	}

	if t.Status != TransactionStatusCompleted && t.Status != TransactionStatusFailed {
		return ErrInvalidTransactionStatus
	}

	// Validate time constraints
	now := time.Now()
	if t.OccurredAt.After(now) {
		return ErrOccurredAtInFuture
	}

	if t.OccurredAt.After(t.RecordedAt) {
		return ErrOccurredAtAfterRecorded
	}

	// For completed transactions, verify ledger balance
	if t.Status == TransactionStatusCompleted {
		if err := t.VerifyBalance(); err != nil {
			return err
		}
	}

	return nil
}

// VerifyBalance verifies that the transaction's entries balance (SUM(debit) = SUM(credit))
// This is a NON-NEGOTIABLE constitutional requirement
func (t *Transaction) VerifyBalance() error {
	if len(t.Entries) == 0 {
		return ErrTransactionNotBalanced
	}

	debitSum := new(big.Int)
	creditSum := new(big.Int)

	for _, entry := range t.Entries {
		if entry.IsDebit() {
			debitSum.Add(debitSum, entry.Amount)
		} else {
			creditSum.Add(creditSum, entry.Amount)
		}
	}

	if debitSum.Cmp(creditSum) != 0 {
		return ErrTransactionNotBalanced
	}

	return nil
}

// IsCompleted returns true if the transaction completed successfully
func (t *Transaction) IsCompleted() bool {
	return t.Status == TransactionStatusCompleted
}

// IsFailed returns true if the transaction failed
func (t *Transaction) IsFailed() bool {
	return t.Status == TransactionStatusFailed
}

// TotalDebitAmount returns the sum of all debit amounts
func (t *Transaction) TotalDebitAmount() *big.Int {
	total := new(big.Int)
	for _, entry := range t.Entries {
		if entry.IsDebit() {
			total.Add(total, entry.Amount)
		}
	}
	return total
}

// TotalCreditAmount returns the sum of all credit amounts
func (t *Transaction) TotalCreditAmount() *big.Int {
	total := new(big.Int)
	for _, entry := range t.Entries {
		if entry.IsCredit() {
			total.Add(total, entry.Amount)
		}
	}
	return total
}

// DebitCredit represents whether an entry is a debit or credit
type DebitCredit string

const (
	Debit  DebitCredit = "DEBIT"
	Credit DebitCredit = "CREDIT"
)

// EntryType represents the type of ledger entry
type EntryType string

const (
	EntryTypeAssetIncrease EntryType = "asset_increase"
	EntryTypeAssetDecrease EntryType = "asset_decrease"
	EntryTypeIncome        EntryType = "income"
	EntryTypeExpense       EntryType = "expense"
	EntryTypeGasFee        EntryType = "gas_fee"
)

// Entry represents a single debit or credit entry in the double-entry ledger
// IMMUTABLE: Entries are never updated or deleted per constitution
type Entry struct {
	ID            uuid.UUID
	TransactionID uuid.UUID
	AccountID     uuid.UUID
	DebitCredit   DebitCredit
	EntryType     EntryType
	Amount        *big.Int // Amount in base units (wei, satoshi, lamports)
	AssetID       string
	USDRate       *big.Int  // USD rate scaled by 10^8
	USDValue      *big.Int  // amount * usd_rate / 10^8
	OccurredAt    time.Time // Matches transaction occurred_at
	CreatedAt     time.Time
	Metadata      map[string]interface{} // Extensible metadata (stored as JSONB)
}

// Validate validates the entry
func (e *Entry) Validate() error {
	// Validate debit/credit
	if e.DebitCredit != Debit && e.DebitCredit != Credit {
		return ErrInvalidDebitCredit
	}

	// Validate amounts are non-negative
	if e.Amount == nil || e.Amount.Sign() < 0 {
		return ErrNegativeAmount
	}

	if e.USDRate == nil || e.USDRate.Sign() < 0 {
		return ErrNegativeUSDRate
	}

	if e.USDValue == nil || e.USDValue.Sign() < 0 {
		return ErrNegativeUSDValue
	}

	// Validate asset ID
	if e.AssetID == "" {
		return ErrInvalidAssetID
	}

	return nil
}

// IsDebit returns true if this entry is a debit
func (e *Entry) IsDebit() bool {
	return e.DebitCredit == Debit
}

// IsCredit returns true if this entry is a credit
func (e *Entry) IsCredit() bool {
	return e.DebitCredit == Credit
}

// SignedAmount returns the amount with the appropriate sign for balance calculations
// Debits are positive, credits are negative
func (e *Entry) SignedAmount() *big.Int {
	result := new(big.Int).Set(e.Amount)
	if e.IsCredit() {
		result.Neg(result)
	}
	return result
}

// AccountType represents the type of ledger account
type AccountType string

const (
	AccountTypeCryptoWallet AccountType = "CRYPTO_WALLET"
	AccountTypeIncome       AccountType = "INCOME"
	AccountTypeExpense      AccountType = "EXPENSE"
	AccountTypeGasFee       AccountType = "GAS_FEE"
)

// Account represents a ledger account for tracking balances
type Account struct {
	ID        uuid.UUID
	Code      string      // Human-readable code (e.g., "wallet.{wallet_id}.{asset_id}")
	Type      AccountType
	AssetID   string   // BTC, ETH, USDC, etc.
	WalletID  *uuid.UUID // Optional: NULL for INCOME/EXPENSE/GAS_FEE accounts
	ChainID   *string    // Optional: inherited from wallet or standalone
	CreatedAt time.Time
	Metadata  map[string]interface{} // Extensible metadata (stored as JSONB)
}

// IsWalletAccount returns true if this is a crypto wallet account
func (a *Account) IsWalletAccount() bool {
	return a.Type == AccountTypeCryptoWallet
}

// IsIncomeAccount returns true if this is an income account
func (a *Account) IsIncomeAccount() bool {
	return a.Type == AccountTypeIncome
}

// IsExpenseAccount returns true if this is an expense account
func (a *Account) IsExpenseAccount() bool {
	return a.Type == AccountTypeExpense
}

// IsGasFeeAccount returns true if this is a gas fee account
func (a *Account) IsGasFeeAccount() bool {
	return a.Type == AccountTypeGasFee
}

// Validate validates the account
func (a *Account) Validate() error {
	if a.Code == "" {
		return ErrInvalidAccountCode
	}

	if a.AssetID == "" {
		return ErrInvalidAssetID
	}

	// Validate account type
	switch a.Type {
	case AccountTypeCryptoWallet:
		if a.WalletID == nil {
			return ErrWalletAccountRequiresWalletID
		}
	case AccountTypeIncome, AccountTypeExpense, AccountTypeGasFee:
		// These accounts should not have a wallet ID
		if a.WalletID != nil {
			return ErrNonWalletAccountCannotHaveWalletID
		}
	default:
		return ErrInvalidAccountType
	}

	return nil
}

// AccountBalance represents the denormalized current balance for an account/asset
// This is maintained for performance and is reconcilable from ledger entries
type AccountBalance struct {
	AccountID   uuid.UUID
	AssetID     string
	Balance     *big.Int  // Current balance in base units
	USDValue    *big.Int  // At current price, updated periodically
	LastUpdated time.Time
}

// Validate validates the account balance
func (b *AccountBalance) Validate() error {
	if b.AssetID == "" {
		return ErrInvalidAssetID
	}

	if b.Balance == nil || b.Balance.Sign() < 0 {
		return ErrNegativeBalance
	}

	if b.USDValue == nil || b.USDValue.Sign() < 0 {
		return ErrNegativeUSDValue
	}

	return nil
}

// IsZero returns true if the balance is zero
func (b *AccountBalance) IsZero() bool {
	return b.Balance.Sign() == 0
}

// IsPositive returns true if the balance is positive
func (b *AccountBalance) IsPositive() bool {
	return b.Balance.Sign() > 0
}
