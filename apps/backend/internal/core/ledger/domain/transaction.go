package domain

import (
	"math/big"
	"time"

	"github.com/google/uuid"
)

// TransactionStatus represents the status of a transaction
type TransactionStatus string

const (
	TransactionStatusCompleted TransactionStatus = "COMPLETED"
	TransactionStatusFailed    TransactionStatus = "FAILED"
)

// Transaction represents a financial transaction that generates ledger entries
// This is the aggregate root for the double-entry system
type Transaction struct {
	ID           uuid.UUID
	Type         string            // manual_income, manual_outcome, asset_adjustment, etc.
	Source       string            // manual, debank, etherscan, etc.
	ExternalID   *string           // Blockchain tx hash or external system ID
	Status       TransactionStatus
	Version      int               // Optimistic locking
	OccurredAt   time.Time         // When transaction actually happened
	RecordedAt   time.Time         // When recorded in our system
	RawData      map[string]interface{} // Original transaction struct for audit (JSONB)
	Metadata     map[string]interface{} // Additional metadata (JSONB)
	ErrorMessage *string           // If status = FAILED
	Entries      []*Entry          // Ledger entries generated by this transaction
}

// Validate validates the transaction
func (t *Transaction) Validate() error {
	if t.Type == "" {
		return ErrInvalidTransactionType
	}

	if t.Status != TransactionStatusCompleted && t.Status != TransactionStatusFailed {
		return ErrInvalidTransactionStatus
	}

	// Validate time constraints
	now := time.Now()
	if t.OccurredAt.After(now) {
		return ErrOccurredAtInFuture
	}

	if t.OccurredAt.After(t.RecordedAt) {
		return ErrOccurredAtAfterRecorded
	}

	// For completed transactions, verify ledger balance
	if t.Status == TransactionStatusCompleted {
		if err := t.VerifyBalance(); err != nil {
			return err
		}
	}

	return nil
}

// VerifyBalance verifies that the transaction's entries balance (SUM(debit) = SUM(credit))
// This is a NON-NEGOTIABLE constitutional requirement
func (t *Transaction) VerifyBalance() error {
	if len(t.Entries) == 0 {
		return ErrTransactionNotBalanced
	}

	debitSum := new(big.Int)
	creditSum := new(big.Int)

	for _, entry := range t.Entries {
		if entry.IsDebit() {
			debitSum.Add(debitSum, entry.Amount)
		} else {
			creditSum.Add(creditSum, entry.Amount)
		}
	}

	if debitSum.Cmp(creditSum) != 0 {
		return ErrTransactionNotBalanced
	}

	return nil
}

// IsCompleted returns true if the transaction completed successfully
func (t *Transaction) IsCompleted() bool {
	return t.Status == TransactionStatusCompleted
}

// IsFailed returns true if the transaction failed
func (t *Transaction) IsFailed() bool {
	return t.Status == TransactionStatusFailed
}

// TotalDebitAmount returns the sum of all debit amounts
func (t *Transaction) TotalDebitAmount() *big.Int {
	total := new(big.Int)
	for _, entry := range t.Entries {
		if entry.IsDebit() {
			total.Add(total, entry.Amount)
		}
	}
	return total
}

// TotalCreditAmount returns the sum of all credit amounts
func (t *Transaction) TotalCreditAmount() *big.Int {
	total := new(big.Int)
	for _, entry := range t.Entries {
		if entry.IsCredit() {
			total.Add(total, entry.Amount)
		}
	}
	return total
}
