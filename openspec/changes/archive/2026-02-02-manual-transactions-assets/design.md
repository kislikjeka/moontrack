## Context

Текущая реализация ручных транзакций использует хардкодированный список ассетов на фронтенде. При создании транзакции пользователь может ввести любой тикер без проверки его существования. Цена не заполняется автоматически — пользователь должен вручную включить опцию и ввести значение.

Существующий `PriceService` работает с CoinGecko ID (например, "bitcoin"), но фронтенд использует символы (BTC). Нет маппинга между символами и CoinGecko ID.

## Goals / Non-Goals

**Goals:**
- Поиск ассетов по названию/символу с автодополнением
- Автоматическое получение текущей цены при выборе ассета
- Валидация существования ассета на бэкенде

**Non-Goals:**
- Кастомные (не CoinGecko) ассеты — оставить возможность, но без валидации цены
- Историческая цена на конкретную дату — текущая реализация достаточна
- Кэширование списка всех ассетов CoinGecko — слишком большой объем данных

## Decisions

### 1. Использовать CoinGecko Search API для поиска ассетов

**Решение:** Добавить метод `SearchCoins` в CoinGecko клиент, использующий `/search` эндпоинт.

**Альтернативы:**
- Загрузить полный список ассетов в Redis (~15000 монет) — отклонено: большой объем, устаревание данных
- Использовать только предзагруженный список популярных монет — отклонено: не решает проблему кастомных ассетов

**Обоснование:** CoinGecko `/search` API бесплатен, возвращает релевантные результаты, включает маппинг symbol → id.

### 2. Кэшировать результаты поиска в Redis на 24 часа

**Решение:** Кэшировать результаты поиска по ключу `asset:search:<query>` с TTL 24h.

**Обоснование:** Список криптовалют меняется редко. 24-часовой кэш снижает нагрузку на API и ускоряет повторные запросы.

### 3. Хранить маппинг symbol → CoinGecko ID

**Решение:** При успешном поиске сохранять маппинг `asset:mapping:<symbol>` → `<coingecko_id>` в Redis на 7 дней.

**Альтернативы:**
- Передавать CoinGecko ID с фронтенда — отклонено: усложняет API, требует изменения схемы транзакций
- Искать каждый раз при создании транзакции — отклонено: медленно, лишние API-вызовы

**Обоснование:** Позволяет использовать символы в API транзакций, а маппинг делать прозрачно на бэкенде.

### 4. Структура модуля assets

**Решение:** Создать новый модуль `internal/modules/assets/` со своим сервисом и хэндлерами.

```
internal/modules/assets/
├── domain/
│   └── asset.go          # Asset struct, SearchResult
├── service/
│   └── asset_service.go  # Search, GetPrice, ResolveSymbol
└── api/
    └── handler.go        # HTTP handlers
```

**Обоснование:** Следует существующей модульной архитектуре. Инкапсулирует логику работы с ассетами.

### 5. Фронтенд: Debounced autocomplete с минимум 2 символами

**Решение:** Использовать debounce 300ms, минимальная длина запроса — 2 символа.

**Обоснование:** Баланс между отзывчивостью и нагрузкой на API. Предотвращает лишние запросы при быстром наборе.

## Risks / Trade-offs

**[Risk] CoinGecko API rate limits** → Использовать существующий circuit breaker и кэширование. Для search API лимит 10-30 req/min на бесплатном плане.

**[Risk] Символ может соответствовать нескольким монетам (например, LUNA)** → Возвращать список результатов с market cap rank, пользователь выбирает нужную.

**[Risk] Ассет не найден в CoinGecko** → Разрешать создание транзакции с предупреждением "цена не может быть получена автоматически".

**[Trade-off] Маппинг symbol → id не 100% надежен** → Сохраняем CoinGecko ID в транзакции для точного определения в будущем.
